<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EM Wave + Electron Cloud</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Arial', sans-serif;
            background: #f0f2f5;
        }
        #info { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            color: #333;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
        }
        #gui { 
            position: absolute; 
            top: 20px; 
            right: 20px; 
        }
        
        /* Reset any dat.GUI styles that might be causing issues */
        .dg.ac {
            z-index: 1000 !important;
            opacity: 1 !important;
            visibility: visible !important;
            display: block !important;
        }
        
        /* Modern styling for dat.GUI */
        .dg.main {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif !important;
        }
        
        .dg.main .close-button {
            border-radius: 5px !important;
        }
        
        .dg.main .close-button:hover {
            background-color: #ff3366 !important;
        }
        
        .dg.main .title {
            border-radius: 4px 4px 0 0 !important;
            background: linear-gradient(to right, #8004bc, #ff12b0) !important;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.3) !important;
        }
        
        .dg.main .cr {
            border-radius: 0 !important;
            border-left: 3px solid transparent !important;
            transition: all 0.2s ease !important;
        }
        
        .dg.main .cr:hover {
            border-left-color: #8004bc !important;
            background-color: rgba(255,255,255,0.1) !important;
        }
        
        .dg.main .c input[type=text] {
            border-radius: 3px !important;
            padding: 2px 5px !important;
        }
        
        .dg.main .c .slider {
            border-radius: 2px !important;
            background: #444 !important;
        }
        
        .dg.main .c .slider .slider-fg {
            background: linear-gradient(to right, #8004bc, #ff12b0) !important;
            border-radius: 2px !important;
        }
        
        .dg.main select {
            border-radius: 3px !important;
        }
        
        /* Make the entire GUI panel have rounded corners */
        .dg.ac {
            border-radius: 6px !important;
            overflow: hidden !important;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2) !important;
        }
    </style>
</head>
<body>
    <div id="info">EM Wave Interacting with Electron Cloud</div>
    <div id="gui"></div>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.7/build/dat.gui.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x181a1b); // dark gray
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(3, 1, 5); // Angled view to see wave profile

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.target.set(0, -0.5, 0); // Focus on interaction area

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        // Electron Cloud (Quantum Probability Density)
        const cloudGeometry = new THREE.SphereGeometry(1, 64, 64);
        const cloudMaterial = new THREE.ShaderMaterial({
            uniforms: { 
                time: { value: 0 },
                density: { value: 1.0 },
                waveInteraction: { value: 0.0 }
            },
            vertexShader: `
                uniform float time;
                varying vec3 vPosition;
                varying float vDistance;
                
                void main() {
                    vPosition = position;
                    vDistance = length(position);
                    
                    // Create a standing wave that rises from the XZ plane (y=0)
                    float waveFreq = 3.0;
                    float waveSpeed = 1.0;
                    
                    // Create standing wave pattern that rises from the plane
                    float standingWave = 0.0;
                    
                    // Apply displacement to all points, but stronger above the XZ plane
                    standingWave = 0.3 * sin(waveFreq * position.x - time * waveSpeed);
                    // Fade out effect as we move away from center
                    standingWave *= (1.0 - smoothstep(0.0, 1.0, length(position.xz)));
                    
                    // Apply displacement in the y-direction to create rising waves
                    vec3 newPosition = position;
                    newPosition.y += standingWave;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                uniform float density;
                uniform float waveInteraction;
                varying vec3 vPosition;
                varying float vDistance;
                
                void main() {
                    // Calculate distance from XZ plane (y=0)
                    float yDist = abs(vPosition.y);
                    
                    // Create a standing wave pattern that rises from the plane
                    float waveFreq = 3.0;
                    float waveSpeed = 1.0;
                    float standingWave = 0.5 + 0.5 * sin(waveFreq * vPosition.x - time * waveSpeed);
                    
                    // Create horizontal bands to visualize the standing wave
                    float bands = pow(abs(sin(waveFreq * vPosition.x - time * waveSpeed)), 4.0);
                    
                    // Create a radial falloff from the center
                    float radialFalloff = exp(-length(vPosition.xz) * density);
                    
                    // Create a vertical falloff (stronger near the plane)
                    float verticalFalloff = exp(-yDist * 1.0); // Less steep falloff
                    
                    // Combine effects
                    float intensity = radialFalloff * verticalFalloff * (0.5 + 0.5 * standingWave);
                    
                    // Color gradient
                    vec3 baseColor = vec3(0.2, 0.4, 1.0);
                    vec3 waveColor = vec3(0.5, 0.7, 1.0);
                    vec3 finalColor = mix(baseColor, waveColor, standingWave);
                    
                    // Brighten the wave pattern
                    finalColor *= (1.0 + intensity * 0.5);
                    
                    // Much higher opacity for better visibility
                    float opacity = clamp(0.7 * intensity + 0.4 * bands * verticalFalloff, 0.2, 0.9);
                    
                    // Add special handling for top-down view
                    // Calculate view-dependent opacity boost
                    float viewFactor = abs(normalize(vPosition).y);
                    opacity = mix(opacity, opacity * 1.5, viewFactor);
                    
                    gl_FragColor = vec4(finalColor, opacity);
                }
            `,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: false // Important for proper transparency
        });
        const electronCloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
        scene.add(electronCloud);

        // Nucleus
        const nucleusGeometry = new THREE.SphereGeometry(0.1, 32, 32);
        const nucleusMaterial = new THREE.MeshBasicMaterial({ color: 0xe53935 });
        const nucleus = new THREE.Mesh(nucleusGeometry, nucleusMaterial);
        scene.add(nucleus);

        // Plane Wave (Proper Sinusoidal EM Wave)
        const waveGeometry = new THREE.PlaneGeometry(30, 30, 400, 400); // Much larger plane with more segments
        const waveMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                wavelength: { value: 2.0 },
                speed: { value: 1.0 },
                amplitude: { value: 0.5 },
                waveWidth: { value: 5.0 }, // New uniform for wave width
                intersectionGlow: { value: 0.0 },
                color1: { value: new THREE.Color(0x8004bc) }, // Top color (purple)
                color2: { value: new THREE.Color(0xff12b0) },  // Bottom color (pink)
                waveRadius: { value: 5.0 } // Control radius of wave effect
            },
            vertexShader: `
                uniform float time;
                uniform float wavelength;
                uniform float speed;
                uniform float amplitude;
                uniform float waveRadius;
                uniform float waveWidth; // New uniform for wave width
                varying vec3 vPosition;
                varying float vWaveHeight;
                varying float vEdgeFade;
                varying float vGradientFactor;
                varying float vIsInWaveArea;
                varying float vDisplacedZ; // NEW

                void main() {
                    vPosition = position;
                    
                    // Calculate wave properties
                    float k = 2.0 * 3.141592 / wavelength;
                    
                    // Create waves moving from left to right (along X axis)
                    float wavePhase = k * (position.x - time * speed);
                    
                    // Z-axis narrowing with rapid falloff at z=±2
                    float zThreshold = 2.0;
                    float zSharpness = 8.0;
                    float zFactor = 1.0 / (1.0 + exp(zSharpness * (abs(position.y) - zThreshold)));
                    
                    // Apply wave width factor - this narrows the wave in the X direction
                    float xFactor = exp(-pow(position.y / waveWidth, 2.0));
                    
                    float distFromCenter = length(position.xz);
                    float waveAreaFactor = smoothstep(waveRadius, waveRadius - 1.0, distFromCenter);
                    vIsInWaveArea = waveAreaFactor;
                    
                    float waveHeight = amplitude * (0.5 + 0.5 * sin(wavePhase));
                    vWaveHeight = waveHeight * waveAreaFactor * zFactor * xFactor; // Apply xFactor here
                    vEdgeFade = smoothstep(waveRadius - 1.0, waveRadius, distFromCenter);
                    vGradientFactor = vWaveHeight;
                    
                    vec3 newPosition = position;
                    newPosition.z += vWaveHeight;
                    vDisplacedZ = newPosition.z; // NEW: pass displaced Z to fragment shader
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
                }
            `,
            // Completely rewritten fragmentShader:
            fragmentShader: `
                uniform vec3 color1;
                uniform vec3 color2;
                uniform float intersectionGlow;
                uniform float waveRadius;
                varying vec3 vPosition;
                varying float vWaveHeight;
                varying float vEdgeFade;
                varying float vGradientFactor;
                varying float vIsInWaveArea;
                varying float vDisplacedZ;
            
                // Draw a grid line if within threshold of an integer value
                float getGridLine(float position, float lineWidth, float lineSpacing) {
                    float halfWidth = lineWidth * 0.5;
                    // Scale position for desired grid spacing
                    position = position / lineSpacing;
                    // Determine distance to nearest integer
                    float distToInt = abs(position - round(position));
                    // lineWidth controls how thin/thick the lines are
                    float lineThreshold = halfWidth / lineSpacing;
                    
                    // Return 1.0 if we're on a line, 0.0 otherwise
                    return 1.0 - step(lineThreshold, distToInt);
                }
            
                void main() {
                    float distFromCenter = length(vPosition.xz);
                    float radialFade = smoothstep(waveRadius - 2.0, waveRadius, distFromCenter);
                
                    // Enhanced gradient with intermediate colors
                    float zMin = 0.0;
                    float zMax = 0.5;
                    float zBlend = clamp((vDisplacedZ - zMin) / (zMax - zMin), 0.0, 1.0);
                    
                    // Create a more dramatic gradient with intermediate colors
                    // that are derived from the selected top and bottom colors
                    vec3 waveColor;
                    if (zBlend < 0.33) {
                        // Bottom third - blend from bottom color to first intermediate color
                        // First intermediate is 2/3 bottom color + 1/3 top color
                        vec3 intermediateColor1 = mix(color2, color1, 0.33);
                        waveColor = mix(color2, intermediateColor1, zBlend * 3.0);
                    } else if (zBlend < 0.66) {
                        // Middle third - blend between two intermediate colors
                        // First intermediate is 2/3 bottom color + 1/3 top color
                        vec3 intermediateColor1 = mix(color2, color1, 0.33);
                        // Second intermediate is 1/3 bottom color + 2/3 top color
                        vec3 intermediateColor2 = mix(color2, color1, 0.66);
                        waveColor = mix(intermediateColor1, intermediateColor2, (zBlend - 0.33) * 3.0);
                    } else {
                        // Top third - blend from second intermediate color to top color
                        // Second intermediate is 1/3 bottom color + 2/3 top color
                        vec3 intermediateColor2 = mix(color2, color1, 0.66);
                        waveColor = mix(intermediateColor2, color1, (zBlend - 0.66) * 3.0);
                    }
                    
                    // Grid parameters
                    float lineWidth = 0.02;   // Width of grid lines
                    float gridSpacing = 0.5;  // Distance between grid lines
                    
                    // IMPORTANT: We use the raw X and Z coordinates for grid lines
                    // When we're working with the plane, we need to use X and Y from vPosition
                    // since the plane is rotated (Y in 3D space becomes Z in plane space)
                    float xGrid = getGridLine(vPosition.x, lineWidth, gridSpacing);
                    float zGrid = getGridLine(vPosition.y, lineWidth, gridSpacing); 
                    
                    // Combine the grid lines - if either axis has a line, show it
                    float gridValue = max(xGrid, zGrid);
                    
                    // Make grid lines more visible by adjusting intensity
                    float gridIntensity = 0.35;
                    vec3 gridColor = vec3(0.05); // Very dark gray grid lines
                    
                    // Apply grid throughout the entire plane (removed radius limitation)
                    waveColor = mix(waveColor, gridColor, gridValue * gridIntensity);
                
                    float lightFactor = 0.7 + 0.3 * abs(vWaveHeight);
                    float opacity = 0.98; // More solid
                
                    vec3 finalColor = waveColor * lightFactor + vec3(0.1, 0.1, 0.2) * intersectionGlow;
                
                    gl_FragColor = vec4(finalColor, opacity);
                }
            `,
            transparent: true,
            side: THREE.DoubleSide
        });
        const wave = new THREE.Mesh(waveGeometry, waveMaterial);
        wave.rotation.x = -Math.PI / 2;
        wave.position.y = 0; // Move the wave up to be at the same level as the atom
        scene.add(wave);

        // Add a subtle reference ground plane to better see the morphing effect
        const groundGeometry = new THREE.PlaneGeometry(12, 6);
        const groundMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x050505, // much darker ground
            transparent: true, 
            opacity: 0.9,    // almost invisible
            wireframe: false  // solid, not wireframe
        });
        // For the ground, add a grid helper for visual clarity:
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.05;
        scene.add(ground);
        
        // Updated GridHelper: Remove it since we'll have shader-based grid
        // const gridHelper = new THREE.GridHelper(12, 24, 0x222222, 0x222222);
        // gridHelper.position.y = -0.051;
        // scene.add(gridHelper);

        // Add coordinate axes for better orientation
        // Remove the old axis creation code
        // function createAxis(length, color) {
        //     const material = new THREE.LineBasicMaterial({ color: color });
        //     const points = [];
        //     points.push(new THREE.Vector3(0, 0, 0));
        //     points.push(new THREE.Vector3(length, 0, 0));
        //     const geometry = new THREE.BufferGeometry().setFromPoints(points);
        //     return new THREE.Line(geometry, material);
        // }
        
        // Create X, Y, Z axes with modern styling
        function createModernAxis(length, color, divisions = 5) {
            const group = new THREE.Group();
            
            // Create main axis line
            const material = new THREE.LineBasicMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.7,
                linewidth: 1.5 // Note: linewidth only works in WebGLRenderer with certain limitations
            });
            
            const points = [];
            points.push(new THREE.Vector3(0, 0, 0));
            points.push(new THREE.Vector3(length, 0, 0));
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, material);
            group.add(line);
            
            // Add tick marks
            const tickSize = 0.05;
            for (let i = 1; i <= divisions; i++) {
                const tickMaterial = new THREE.LineBasicMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.5
                });
                
                const tickPoints = [];
                tickPoints.push(new THREE.Vector3(i, -tickSize, 0));
                tickPoints.push(new THREE.Vector3(i, tickSize, 0));
                
                const tickGeometry = new THREE.BufferGeometry().setFromPoints(tickPoints);
                const tick = new THREE.Line(tickGeometry, tickMaterial);
                group.add(tick);
            }
            
            return group;
        }
        
        // Create modern axes
        const xAxis = createModernAxis(5, 0xf44336); // Modern red
        const yAxis = createModernAxis(5, 0x4CAF50); // Modern green
        const zAxis = createModernAxis(5, 0x2196F3); // Modern blue
        
        // Rotate Y and Z axes to proper orientation
        yAxis.rotation.z = Math.PI / 2; // Rotate around Z to point up
        zAxis.rotation.y = Math.PI / 2; // Rotate around Y to point forward
        
        // Add axes to scene
        scene.add(xAxis);
        scene.add(yAxis);
        scene.add(zAxis);
        
        // Create modern axis labels with physical units
        function createModernAxisLabel(text, position, color, size = 0.4, isUnitLabel = false) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            
            // Clear background with transparency
            context.clearRect(0, 0, canvas.width, canvas.height);
            
            // Set text properties - larger font for unit labels
            const hexColor = '#' + color.toString(16).padStart(6, '0');
            context.fillStyle = hexColor;
            
            // Use larger font size for all labels
            context.font = isUnitLabel ? 'bold 48px Arial' : 'bold 42px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // Add text with shadow for better visibility
            context.shadowColor = 'rgba(0,0,0,0.5)';
            context.shadowBlur = 4;
            context.shadowOffsetX = 2;
            context.shadowOffsetY = 2;
            context.fillText(text, canvas.width/2, canvas.height/2);
            
            // Create texture and sprite
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            const material = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                depthTest: false, // Make sure labels are always visible
                depthWrite: false // Prevent labels from being occluded by other objects
            });
            
            const sprite = new THREE.Sprite(material);
            sprite.position.copy(position);
            
            // Larger scale for all labels
            sprite.scale.set(size, size/2, 1);
            sprite.renderOrder = 999; // Ensure labels render on top of everything
            
            return sprite;
        }
        
        // Add main axis labels with correct physical units - positioned closer to center
        scene.add(createModernAxisLabel('x (nm)', new THREE.Vector3(3.0, 0.3, 0), 0xf44336, 0.8, true));
        scene.add(createModernAxisLabel('E (V/m)', new THREE.Vector3(0, 3.0, 0), 0x4CAF50, 0.8, true));
        scene.add(createModernAxisLabel('B (μT)', new THREE.Vector3(0, 0.3, 3.0), 0x2196F3, 0.8, true));
        
        // Add numbered markers on axes with units - positioned above the plane with larger size
        for (let i = 1; i <= 5; i++) {
            // X-axis markers (distance in nanometers) - adjusted to show smaller values
            scene.add(createModernAxisLabel((i*0.05).toFixed(2), new THREE.Vector3(i, 0.25, 0), 0xf44336, 0.5));
            
            // Y-axis markers (electric field in V/m)
            scene.add(createModernAxisLabel((i*20).toString(), new THREE.Vector3(-0.25, i, 0), 0x4CAF50, 0.5));
            
            // Z-axis markers (magnetic field in μT)
            scene.add(createModernAxisLabel((i*0.07).toFixed(2), new THREE.Vector3(0, 0.25, i), 0x2196F3, 0.5));
            
            // Negative markers (except for Y which starts at ground level)
            if (i > 0) {
                scene.add(createModernAxisLabel('-'+(i*0.05).toFixed(2), new THREE.Vector3(-i, 0.25, 0), 0xf44336, 0.5));
                scene.add(createModernAxisLabel('-'+(i*0.07).toFixed(2), new THREE.Vector3(0, 0.25, -i), 0x2196F3, 0.5));
            }
        }

        // GUI
        // GUI
        const gui = new dat.GUI({ autoPlace: true });
        document.getElementById('gui').appendChild(gui.domElement);
        
        const params = {
            wavelength: 2.0,
            waveSpeed: 1.0,
            amplitude: 0.5,
            waveWidth: 5.0,  // New parameter for wave width
            electronDensity: 1.0,
            topColor: '#8004bc',
            bottomColor: '#ff12b0',
            waveRadius: 5.0,
            pause: false
        };
        
        // Add wavelength controller with custom display
        const wavelengthController = gui.add(params, 'wavelength', 0.5, 5).name('Wavelength (nm)');
        wavelengthController.onChange((val) => {
            waveMaterial.uniforms.wavelength.value = val;
            wavelengthController.name('Wavelength (nm): ' + (val * 0.05).toFixed(2));
        });
        
        // Update the initial display name
        wavelengthController.name('Wavelength (nm): ' + (params.wavelength * 0.05).toFixed(2));
        
        // Add wave width controller
        gui.add(params, 'waveWidth', 1.0, 10.0).name('Wave Width').onChange((val) => {
            // Update the shader uniform for wave width
            waveMaterial.uniforms.waveWidth.value = val;
        });
        
        // Rest of the controllers
        gui.add(params, 'waveSpeed', 0.1, 2).name('Wave Speed');
        gui.add(params, 'amplitude', 0.1, 1.0).name('Wave Height');
        gui.add(params, 'electronDensity', 0.5, 2.0).name('Electron Density').onChange((val) => {
            cloudMaterial.uniforms.density.value = val;
        });
        gui.add(params, 'waveRadius', 1.0, 10.0).name('Wave Radius').onChange((val) => {
            waveMaterial.uniforms.waveRadius.value = val;
        });
        gui.addColor(params, 'topColor').name('Top Color').onChange((val) => {
            waveMaterial.uniforms.color1.value.set(val);
        });
        gui.addColor(params, 'bottomColor').name('Bottom Color').onChange((val) => {
            waveMaterial.uniforms.color2.value.set(val);
        });
        gui.add(params, 'pause').name('Pause Animation');

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const time = performance.now() * 0.001;
            
            // Update wave material
            waveMaterial.uniforms.time.value = time;
            
            // Update electron cloud material
            if (electronCloud && electronCloud.material.uniforms) {
                electronCloud.material.uniforms.time.value = time;
            }
            
            // Update controls
            controls.update();
            
            renderer.render(scene, camera);
        }
        
        animate();

        // Re-radiated ripple effect
        function spawnRipple(position) {
            const geometry = new THREE.SphereGeometry(0.1, 16, 16);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x88ffff, 
                transparent: true, 
                opacity: 0.7 
            });
            const ripple = new THREE.Mesh(geometry, material);
            ripple.position.copy(position);
            scene.add(ripple);

            let scale = 0.1;
            const grow = () => {
                scale += 0.1;
                ripple.scale.set(scale, scale, scale);
                ripple.material.opacity *= 0.95;
                if (scale < 3) requestAnimationFrame(grow);
                else scene.remove(ripple);
            };
            grow();
        }

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>

// Apply custom styling to GUI
const guiElement = document.querySelector('.dg.ac');
if (guiElement) {
    guiElement.style.opacity = '0.95';
    
    // Add a subtle animation when opening/closing folders
    const folders = document.querySelectorAll('.dg.main .folder');
    folders.forEach(folder => {
        folder.style.transition = 'height 0.2s ease-in-out';
    });
    
    // Make the GUI title more attractive
    const title = document.querySelector('.dg.main .title');
    if (title) {
        title.innerHTML = '<span style="font-weight: 600;">EM Wave Controls</span>';
    }
}

        // Electron Cloud as a Standing Wave (Hydrogen 1s Orbital)
        const cloudGeometry = new THREE.SphereGeometry(1, 64, 64);
        const cloudMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                density: { value: 1.0 },
                waveInteraction: { value: 0.0 }
            },
            vertexShader: `
                uniform float time;
                varying vec3 vPosition;
                varying float vDistance;
                
                void main() {
                    vPosition = position;
                    vDistance = length(position);
                    
                    // Create a subtle breathing effect
                    float breathingFactor = 0.05 * sin(time * 0.5);
                    vec3 newPosition = position * (1.0 + breathingFactor);
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                uniform float density;
                uniform float waveInteraction;
                varying vec3 vPosition;
                varying float vDistance;
                
                // Hydrogen 1s orbital wave function
                float hydrogenOrbital(vec3 pos, float n) {
                    float r = length(pos);
                    float a0 = 1.0; // Bohr radius (scaled)
                    
                    // Radial part of the 1s orbital
                    float R = 2.0 * pow(1.0/a0, 1.5) * exp(-r/a0);
                    
                    // Standing wave pattern
                    float standingWave = 0.5 + 0.5 * sin(r * 10.0 - time * 2.0);
                    
                    // Combine for visual effect
                    return R * R * standingWave; // |ψ|²
                }
                
                void main() {
                    // Calculate the hydrogen 1s orbital probability density
                    float psi = hydrogenOrbital(vPosition * density, 1.0);
                    
                    // Create a radial standing wave pattern
                    float standingWave = 0.5 + 0.5 * sin(vDistance * 10.0 - time * 2.0);
                    float breathingEffect = 0.5 + 0.5 * sin(time * 0.5);
                    
                    // Combine the orbital with standing wave pattern
                    float combinedEffect = psi * (0.7 + 0.3 * standingWave);
                    
                    // Color gradient from center (blue) to edge (light blue)
                    vec3 centerColor = vec3(0.2, 0.4, 1.0);
                    vec3 edgeColor = vec3(0.5, 0.7, 1.0);
                    float colorMix = exp(-vDistance * 2.0);
                    vec3 baseColor = mix(edgeColor, centerColor, colorMix);
                    
                    // Add wave interaction effect
                    vec3 interactionColor = vec3(0.6, 0.8, 1.0);
                    vec3 finalColor = mix(baseColor, interactionColor, waveInteraction * 0.5);
                    
                    // Apply the combined effect to create a glowing appearance
                    vec3 glow = finalColor * combinedEffect * 2.0;
                    
                    // Opacity based on distance from center and breathing
                    float baseOpacity = 0.3;
                    float distanceOpacity = exp(-vDistance * density * 1.5) * 0.6;
                    float breathingOpacity = 0.1 * breathingEffect;
                    float opacity = clamp(baseOpacity + distanceOpacity + breathingOpacity, 0.1, 0.7);
                    
                    // Add subtle concentric shells to visualize standing wave nodes
                    float shells = abs(sin(vDistance * 8.0 * density));
                    shells = pow(shells, 8.0); // Sharpen the shells
                    
                    // Add shells to the final color
                    glow += vec3(0.3, 0.5, 1.0) * shells * 0.3;
                    
                    gl_FragColor = vec4(glow, opacity);
                }
            `,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: false // Important for proper transparency
        });
        const electronCloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
        scene.add(electronCloud);

        // Nucleus
        const nucleusGeometry = new THREE.SphereGeometry(0.1, 32, 32);
        const nucleusMaterial = new THREE.MeshBasicMaterial({ color: 0xe53935 });
        const nucleus = new THREE.Mesh(nucleusGeometry, nucleusMaterial);
        scene.add(nucleus);

        // Plane Wave (Proper Sinusoidal EM Wave)
        const waveGeometry = new THREE.PlaneGeometry(30, 30, 400, 400); // Much larger plane with more segments
        const waveMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                wavelength: { value: 2.0 },
                speed: { value: 1.0 },
                amplitude: { value: 0.5 },
                waveWidth: { value: 5.0 }, // New uniform for wave width
                intersectionGlow: { value: 0.0 },
                color1: { value: new THREE.Color(0x8004bc) }, // Top color (purple)
                color2: { value: new THREE.Color(0xff12b0) },  // Bottom color (pink)
                waveRadius: { value: 5.0 } // Control radius of wave effect
            },
            vertexShader: `
                uniform float time;
                uniform float wavelength;
                uniform float speed;
                uniform float amplitude;
                uniform float waveRadius;
                uniform float waveWidth; // New uniform for wave width
                varying vec3 vPosition;
                varying float vWaveHeight;
                varying float vEdgeFade;
                varying float vGradientFactor;
                varying float vIsInWaveArea;
                varying float vDisplacedZ; // NEW

                void main() {
                    vPosition = position;
                    
                    // Calculate wave properties
                    float k = 2.0 * 3.141592 / wavelength;
                    
                    // Create waves moving from left to right (along X axis)
                    float wavePhase = k * (position.x - time * speed);
                    
                    // Z-axis narrowing with rapid falloff at z=±2
                    float zThreshold = 2.0;
                    float zSharpness = 8.0;
                    float zFactor = 1.0 / (1.0 + exp(zSharpness * (abs(position.y) - zThreshold)));
                    
                    // Apply wave width factor - this narrows the wave in the X direction
                    float xFactor = exp(-pow(position.y / waveWidth, 2.0));
                    
                    float distFromCenter = length(position.xz);
                    float waveAreaFactor = smoothstep(waveRadius, waveRadius - 1.0, distFromCenter);
                    vIsInWaveArea = waveAreaFactor;
                    
                    float waveHeight = amplitude * (0.5 + 0.5 * sin(wavePhase));
                    vWaveHeight = waveHeight * waveAreaFactor * zFactor * xFactor; // Apply xFactor here
                    vEdgeFade = smoothstep(waveRadius - 1.0, waveRadius, distFromCenter);
                    vGradientFactor = vWaveHeight;
                    
                    vec3 newPosition = position;
                    newPosition.z += vWaveHeight;
                    vDisplacedZ = newPosition.z; // NEW: pass displaced Z to fragment shader
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
                }
            `,
            // Completely rewritten fragmentShader:
            fragmentShader: `
                uniform vec3 color1;
                uniform vec3 color2;
                uniform float intersectionGlow;
                uniform float waveRadius;
                varying vec3 vPosition;
                varying float vWaveHeight;
                varying float vEdgeFade;
                varying float vGradientFactor;
                varying float vIsInWaveArea;
                varying float vDisplacedZ;
            
                // Draw a grid line if within threshold of an integer value
                float getGridLine(float position, float lineWidth, float lineSpacing) {
                    float halfWidth = lineWidth * 0.5;
                    // Scale position for desired grid spacing
                    position = position / lineSpacing;
                    // Determine distance to nearest integer
                    float distToInt = abs(position - round(position));
                    // lineWidth controls how thin/thick the lines are
                    float lineThreshold = halfWidth / lineSpacing;
                    
                    // Return 1.0 if we're on a line, 0.0 otherwise
                    return 1.0 - step(lineThreshold, distToInt);
                }
            
                void main() {
                    float distFromCenter = length(vPosition.xz);
                    float radialFade = smoothstep(waveRadius - 2.0, waveRadius, distFromCenter);
                
                    // Enhanced gradient with intermediate colors
                    float zMin = 0.0;
                    float zMax = 0.5;
                    float zBlend = clamp((vDisplacedZ - zMin) / (zMax - zMin), 0.0, 1.0);
                    
                    // Create a more dramatic gradient with intermediate colors
                    // that are derived from the selected top and bottom colors
                    vec3 waveColor;
                    if (zBlend < 0.33) {
                        // Bottom third - blend from bottom color to first intermediate color
                        // First intermediate is 2/3 bottom color + 1/3 top color
                        vec3 intermediateColor1 = mix(color2, color1, 0.33);
                        waveColor = mix(color2, intermediateColor1, zBlend * 3.0);
                    } else if (zBlend < 0.66) {
                        // Middle third - blend between two intermediate colors
                        // First intermediate is 2/3 bottom color + 1/3 top color
                        vec3 intermediateColor1 = mix(color2, color1, 0.33);
                        // Second intermediate is 1/3 bottom color + 2/3 top color
                        vec3 intermediateColor2 = mix(color2, color1, 0.66);
                        waveColor = mix(intermediateColor1, intermediateColor2, (zBlend - 0.33) * 3.0);
                    } else {
                        // Top third - blend from second intermediate color to top color
                        // Second intermediate is 1/3 bottom color + 2/3 top color
                        vec3 intermediateColor2 = mix(color2, color1, 0.66);
                        waveColor = mix(intermediateColor2, color1, (zBlend - 0.66) * 3.0);
                    }
                    
                    // Grid parameters
                    float lineWidth = 0.02;   // Width of grid lines
                    float gridSpacing = 0.5;  // Distance between grid lines
                    
                    // IMPORTANT: We use the raw X and Z coordinates for grid lines
                    // When we're working with the plane, we need to use X and Y from vPosition
                    // since the plane is rotated (Y in 3D space becomes Z in plane space)
                    float xGrid = getGridLine(vPosition.x, lineWidth, gridSpacing);
                    float zGrid = getGridLine(vPosition.y, lineWidth, gridSpacing); 
                    
                    // Combine the grid lines - if either axis has a line, show it
                    float gridValue = max(xGrid, zGrid);
                    
                    // Make grid lines more visible by adjusting intensity
                    float gridIntensity = 0.35;
                    vec3 gridColor = vec3(0.05); // Very dark gray grid lines
                    
                    // Apply grid throughout the entire plane (removed radius limitation)
                    waveColor = mix(waveColor, gridColor, gridValue * gridIntensity);
                
                    float lightFactor = 0.7 + 0.3 * abs(vWaveHeight);
                    float opacity = 0.98; // More solid
                
                    vec3 finalColor = waveColor * lightFactor + vec3(0.1, 0.1, 0.2) * intersectionGlow;
                
                    gl_FragColor = vec4(finalColor, opacity);
                }
            `,
            transparent: true,
            side: THREE.DoubleSide
        });
        const wave = new THREE.Mesh(waveGeometry, waveMaterial);
        wave.rotation.x = -Math.PI / 2;
        wave.position.y = 0; // Move the wave up to be at the same level as the atom
        scene.add(wave);

        // Add a subtle reference ground plane to better see the morphing effect
        const groundGeometry = new THREE.PlaneGeometry(12, 6);
        const groundMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x050505, // much darker ground
            transparent: true, 
            opacity: 0.9,    // almost invisible
            wireframe: false  // solid, not wireframe
        });
        // For the ground, add a grid helper for visual clarity:
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.05;
        scene.add(ground);
        
        // Updated GridHelper: Remove it since we'll have shader-based grid
        // const gridHelper = new THREE.GridHelper(12, 24, 0x222222, 0x222222);
        // gridHelper.position.y = -0.051;
        // scene.add(gridHelper);

        // Add coordinate axes for better orientation
        // Remove the old axis creation code
        // function createAxis(length, color) {
        //     const material = new THREE.LineBasicMaterial({ color: color });
        //     const points = [];
        //     points.push(new THREE.Vector3(0, 0, 0));
        //     points.push(new THREE.Vector3(length, 0, 0));
        //     const geometry = new THREE.BufferGeometry().setFromPoints(points);
        //     return new THREE.Line(geometry, material);
        // }
        
        // Create X, Y, Z axes with modern styling
        function createModernAxis(length, color, divisions = 5) {
            const group = new THREE.Group();
            
            // Create main axis line
            const material = new THREE.LineBasicMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.7,
                linewidth: 1.5 // Note: linewidth only works in WebGLRenderer with certain limitations
            });
            
            const points = [];
            points.push(new THREE.Vector3(0, 0, 0));
            points.push(new THREE.Vector3(length, 0, 0));
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, material);
            group.add(line);
            
            // Add tick marks
            const tickSize = 0.05;
            for (let i = 1; i <= divisions; i++) {
                const tickMaterial = new THREE.LineBasicMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.5
                });
                
                const tickPoints = [];
                tickPoints.push(new THREE.Vector3(i, -tickSize, 0));
                tickPoints.push(new THREE.Vector3(i, tickSize, 0));
                
                const tickGeometry = new THREE.BufferGeometry().setFromPoints(tickPoints);
                const tick = new THREE.Line(tickGeometry, tickMaterial);
                group.add(tick);
            }
            
            return group;
        }
        
        // Create modern axes
        const xAxis = createModernAxis(5, 0xf44336); // Modern red
        const yAxis = createModernAxis(5, 0x4CAF50); // Modern green
        const zAxis = createModernAxis(5, 0x2196F3); // Modern blue
        
        // Rotate Y and Z axes to proper orientation
        yAxis.rotation.z = Math.PI / 2; // Rotate around Z to point up
        zAxis.rotation.y = Math.PI / 2; // Rotate around Y to point forward
        
        // Add axes to scene
        scene.add(xAxis);
        scene.add(yAxis);
        scene.add(zAxis);
        
        // Create modern axis labels with physical units
        function createModernAxisLabel(text, position, color, size = 0.4, isUnitLabel = false) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            
            // Clear background with transparency
            context.clearRect(0, 0, canvas.width, canvas.height);
            
            // Set text properties - larger font for unit labels
            const hexColor = '#' + color.toString(16).padStart(6, '0');
            context.fillStyle = hexColor;
            
            // Use larger font size for all labels
            context.font = isUnitLabel ? 'bold 48px Arial' : 'bold 42px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // Add text with shadow for better visibility
            context.shadowColor = 'rgba(0,0,0,0.5)';
            context.shadowBlur = 4;
            context.shadowOffsetX = 2;
            context.shadowOffsetY = 2;
            context.fillText(text, canvas.width/2, canvas.height/2);
            
            // Create texture and sprite
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            const material = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                depthTest: false, // Make sure labels are always visible
                depthWrite: false // Prevent labels from being occluded by other objects
            });
            
            const sprite = new THREE.Sprite(material);
            sprite.position.copy(position);
            
            // Larger scale for all labels
            sprite.scale.set(size, size/2, 1);
            sprite.renderOrder = 999; // Ensure labels render on top of everything
            
            return sprite;
        }
        
        // Add main axis labels with correct physical units - positioned closer to center
        scene.add(createModernAxisLabel('x (nm)', new THREE.Vector3(3.0, 0.3, 0), 0xf44336, 0.8, true));
        scene.add(createModernAxisLabel('E (V/m)', new THREE.Vector3(0, 3.0, 0), 0x4CAF50, 0.8, true));
        scene.add(createModernAxisLabel('B (μT)', new THREE.Vector3(0, 0.3, 3.0), 0x2196F3, 0.8, true));
        
        // Add numbered markers on axes with units - positioned above the plane with larger size
        for (let i = 1; i <= 5; i++) {
            // X-axis markers (distance in nanometers) - adjusted to show smaller values
            scene.add(createModernAxisLabel((i*0.05).toFixed(2), new THREE.Vector3(i, 0.25, 0), 0xf44336, 0.5));
            
            // Y-axis markers (electric field in V/m)
            scene.add(createModernAxisLabel((i*20).toString(), new THREE.Vector3(-0.25, i, 0), 0x4CAF50, 0.5));
            
            // Z-axis markers (magnetic field in μT)
            scene.add(createModernAxisLabel((i*0.07).toFixed(2), new THREE.Vector3(0, 0.25, i), 0x2196F3, 0.5));
            
            // Negative markers (except for Y which starts at ground level)
            if (i > 0) {
                scene.add(createModernAxisLabel('-'+(i*0.05).toFixed(2), new THREE.Vector3(-i, 0.25, 0), 0xf44336, 0.5));
                scene.add(createModernAxisLabel('-'+(i*0.07).toFixed(2), new THREE.Vector3(0, 0.25, -i), 0x2196F3, 0.5));
            }
        }

        // GUI
        // GUI
        const gui = new dat.GUI({ autoPlace: true });
        document.getElementById('gui').appendChild(gui.domElement);
        
        const params = {
            wavelength: 2.0,
            waveSpeed: 1.0,
            amplitude: 0.5,
            waveWidth: 5.0,  // New parameter for wave width
            electronDensity: 1.0,
            topColor: '#8004bc',
            bottomColor: '#ff12b0',
            waveRadius: 5.0,
            pause: false
        };
        
        // Add wavelength controller with custom display
        const wavelengthController = gui.add(params, 'wavelength', 0.5, 5).name('Wavelength (nm)');
        wavelengthController.onChange((val) => {
            waveMaterial.uniforms.wavelength.value = val;
            wavelengthController.name('Wavelength (nm): ' + (val * 0.05).toFixed(2));
        });
        
        // Update the initial display name
        wavelengthController.name('Wavelength (nm): ' + (params.wavelength * 0.05).toFixed(2));
        
        // Add wave width controller
        gui.add(params, 'waveWidth', 1.0, 10.0).name('Wave Width').onChange((val) => {
            // Update the shader uniform for wave width
            waveMaterial.uniforms.waveWidth.value = val;
        });
        
        // Rest of the controllers
        gui.add(params, 'waveSpeed', 0.1, 2).name('Wave Speed');
        gui.add(params, 'amplitude', 0.1, 1.0).name('Wave Height');
        gui.add(params, 'electronDensity', 0.5, 2.0).name('Electron Density').onChange((val) => {
            cloudMaterial.uniforms.density.value = val;
        });
        gui.add(params, 'waveRadius', 1.0, 10.0).name('Wave Radius').onChange((val) => {
            waveMaterial.uniforms.waveRadius.value = val;
        });
        gui.addColor(params, 'topColor').name('Top Color').onChange((val) => {
            waveMaterial.uniforms.color1.value.set(val);
        });
        gui.addColor(params, 'bottomColor').name('Bottom Color').onChange((val) => {
            waveMaterial.uniforms.color2.value.set(val);
        });
        gui.add(params, 'pause').name('Pause Animation');

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const time = performance.now() * 0.001;
            
            // Update wave material
            waveMaterial.uniforms.time.value = time;
            
            // Update electron cloud material
            if (electronCloud && electronCloud.material.uniforms) {
                electronCloud.material.uniforms.time.value = time;
            }
            
            // Update controls
            controls.update();
            
            renderer.render(scene, camera);
        }
        
        animate();

        // Re-radiated ripple effect
        function spawnRipple(position) {
            const geometry = new THREE.SphereGeometry(0.1, 16, 16);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x88ffff, 
                transparent: true, 
                opacity: 0.7 
            });
            const ripple = new THREE.Mesh(geometry, material);
            ripple.position.copy(position);
            scene.add(ripple);

            let scale = 0.1;
            const grow = () => {
                scale += 0.1;
                ripple.scale.set(scale, scale, scale);
                ripple.material.opacity *= 0.95;
                if (scale < 3) requestAnimationFrame(grow);
                else scene.remove(ripple);
            };
            grow();
        }

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>

// Apply custom styling to GUI
const guiElement = document.querySelector('.dg.ac');
if (guiElement) {
    guiElement.style.opacity = '0.95';
    
    // Add a subtle animation when opening/closing folders
    const folders = document.querySelectorAll('.dg.main .folder');
    folders.forEach(folder => {
        folder.style.transition = 'height 0.2s ease-in-out';
    });
    
    // Make the GUI title more attractive
    const title = document.querySelector('.dg.main .title');
    if (title) {
        title.innerHTML = '<span style="font-weight: 600;">EM Wave Controls</span>';
    }
}

        // Electron Cloud (Quantum Probability Density)
        // Create a particle-based electron cloud
        const particleCount = 2000;
        const particlePositions = new Float32Array(particleCount * 3);
        const particleSizes = new Float32Array(particleCount);
        const particleColors = new Float32Array(particleCount * 3);
        
        // Create particles in a disk shape above the plane
        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            
            // Random position within a disk
            const radius = 1.5 * Math.sqrt(Math.random());
            const theta = Math.random() * Math.PI * 2;
            
            particlePositions[i3] = radius * Math.cos(theta);     // x
            particlePositions[i3 + 1] = 0.05;                     // y (just above the plane)
            particlePositions[i3 + 2] = radius * Math.sin(theta); // z
            
            // Random size for particles
            particleSizes[i] = 0.03 + Math.random() * 0.03;
            
            // Blue color with slight variation
            particleColors[i3] = 0.2 + Math.random() * 0.2;     // r
            particleColors[i3 + 1] = 0.4 + Math.random() * 0.2; // g
            particleColors[i3 + 2] = 0.8 + Math.random() * 0.2; // b
        }
        
        const particleGeometry = new THREE.BufferGeometry();
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        particleGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
        particleGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
        
        // Create a shader material for the particles
        const particleMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                pixelRatio: { value: window.devicePixelRatio }
            },
            vertexShader: `
                uniform float time;
                uniform float pixelRatio;
                attribute float size;
                attribute vec3 color;
                varying vec3 vColor;
                
                void main() {
                    vColor = color;
                    
                    // Create a standing wave pattern
                    float waveFreq = 3.0;
                    float waveSpeed = 1.0;
                    float wavePhase = waveFreq * position.x - time * waveSpeed;
                    
                    // Calculate wave height based on position and time
                    float distFromCenter = length(position.xz);
                    float amplitude = 0.5 * (1.0 - min(1.0, distFromCenter / 1.5));
                    float waveHeight = amplitude * sin(wavePhase);
                    
                    // Apply the displacement in the y-direction
                    vec3 newPosition = position;
                    newPosition.y += waveHeight;
                    
                    vec4 mvPosition = modelViewMatrix * vec4(newPosition, 1.0);
                    
                    // Size attenuation based on distance
                    gl_PointSize = size * pixelRatio * (300.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                
                void main() {
                    // Create a circular particle
                    vec2 center = gl_PointCoord - 0.5;
                    float dist = length(center);
                    
                    // Discard pixels outside the circle
                    if (dist > 0.5) discard;
                    
                    // Create a soft edge
                    float alpha = 1.0 - smoothstep(0.3, 0.5, dist);
                    
                    // Output the final color
                    gl_FragColor = vec4(vColor, alpha);
                }
            `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });
        
        const electronCloud = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(electronCloud);