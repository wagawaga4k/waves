<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EM Wave + Electron Cloud</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Arial', sans-serif;
            background: #f0f2f5;
        }
        #info { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            color: #333;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
        }
        #gui { 
            position: absolute; 
            top: 20px; 
            right: 20px; 
        }
    </style>
</head>
<body>
    <div id="info">EM Wave Interacting with Electron Cloud</div>
    <div id="gui"></div>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.7/build/dat.gui.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f2f5);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(3, 1, 5); // Angled view to see wave profile

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.target.set(0, -0.5, 0); // Focus on interaction area

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        // Electron Cloud (Quantum Probability Density)
        const cloudGeometry = new THREE.SphereGeometry(1, 64, 64);
        const cloudMaterial = new THREE.ShaderMaterial({
            uniforms: { 
                time: { value: 0 },
                density: { value: 1.0 },
                waveInteraction: { value: 0.0 } // New uniform for wave interaction
            },
            vertexShader: `
                varying vec3 vPosition;
                void main() {
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                uniform float density;
                uniform float waveInteraction;
                varying vec3 vPosition;
                void main() {
                    float r = length(vPosition);
                    // 1s orbital probability density |ψ|²
                    float psi = exp(-r * density * 2.0);
                    
                    // Add subtle color shift based on wave interaction instead of pulsing
                    vec3 baseColor = vec3(0.4, 0.6, 1.0);
                    vec3 interactionColor = vec3(0.5, 0.8, 1.0);
                    vec3 finalColor = mix(baseColor, interactionColor, waveInteraction * 0.5);
                    
                    vec3 glow = finalColor * psi * 2.0;
                    
                    // Keep opacity more stable with a higher base value
                    float baseOpacity = 0.3;
                    float variableOpacity = 0.2 * psi;
                    float interactionBoost = 0.1 * waveInteraction;
                    
                    // Ensure opacity never drops too low or jumps too high
                    float opacity = clamp(baseOpacity + variableOpacity + interactionBoost, 0.2, 0.5);
                    
                    gl_FragColor = vec4(glow, opacity);
                }
            `,
            transparent: true,
            side: THREE.DoubleSide
        });
        const electronCloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
        scene.add(electronCloud);

        // Nucleus
        const nucleusGeometry = new THREE.SphereGeometry(0.1, 32, 32);
        const nucleusMaterial = new THREE.MeshBasicMaterial({ color: 0xe53935 });
        const nucleus = new THREE.Mesh(nucleusGeometry, nucleusMaterial);
        scene.add(nucleus);

        // Plane Wave (Proper Sinusoidal EM Wave)
        const waveGeometry = new THREE.PlaneGeometry(30, 30, 400, 400); // Much larger plane with more segments
        const waveMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                wavelength: { value: 2.0 },
                speed: { value: 1.0 },
                amplitude: { value: 0.5 },
                intersectionGlow: { value: 0.0 },
                color1: { value: new THREE.Color(0xffffff) }, // Top color (white)
                color2: { value: new THREE.Color(0xff69b4) },  // Bottom color (pink)
                waveRadius: { value: 5.0 } // Control radius of wave effect
            },
            vertexShader: `
                uniform float time;
                uniform float wavelength;
                uniform float speed;
                uniform float amplitude;
                uniform float waveRadius;
                varying vec3 vPosition;
                varying float vWaveHeight;
                varying float vEdgeFade;
                varying float vGradientFactor;
                varying float vIsInWaveArea;

                void main() {
                    vPosition = position;
                    
                    // Calculate wave properties
                    float k = 2.0 * 3.141592 / wavelength;
                    
                    // Create waves moving from left to right (along X axis)
                    float wavePhase = k * (position.x - time * speed);
                    
                    // Z-axis narrowing with rapid falloff at z=±2
                    // Use a steeper function that drops quickly at z=±2
                    float zThreshold = 2.0; // Where wave height should rapidly decrease
                    float zSharpness = 8.0; // How sharp the transition is (higher = sharper)
                    
                    // Sigmoid-like function that drops rapidly at z=±zThreshold
                    float zFactor = 1.0 / (1.0 + exp(zSharpness * (abs(position.y) - zThreshold)));
                    
                    // Determine if this vertex is in the wave-forming area (radial distance)
                    float distFromCenter = length(position.xz);
                    float waveAreaFactor = smoothstep(waveRadius, waveRadius - 1.0, distFromCenter);
                    vIsInWaveArea = waveAreaFactor;
                    
                    // Smooth wave function (more like a gradient rise)
                    float waveHeight = amplitude * (0.5 + 0.5 * sin(wavePhase));
                    
                    // Apply wave height with Z-axis narrowing and wave area factor
                    vWaveHeight = waveHeight * waveAreaFactor * zFactor;
                    
                    // Edge fade within the wave area
                    vEdgeFade = smoothstep(waveRadius - 1.0, waveRadius, distFromCenter);
                    
                    // Save gradient factor for fragment shader
                    vGradientFactor = vWaveHeight;
                    
                    // Displace vertices in 3D space
                    vec3 newPosition = position;
                    
                    // Since the plane is rotated -Math.PI/2 around X-axis,
                    // we need to displace the Z coordinate to create height
                    newPosition.z += vWaveHeight;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 color1;
                uniform vec3 color2;
                uniform float intersectionGlow;
                uniform float waveRadius;
                varying vec3 vPosition;
                varying float vWaveHeight;
                varying float vEdgeFade;
                varying float vGradientFactor;
                varying float vIsInWaveArea;

                void main() {
                    // Z-axis narrowing with rapid falloff at z=±2
                    float zThreshold = 2.0; // Same as in vertex shader
                    float zSharpness = 8.0; // Same as in vertex shader
                    float zFactor = 1.0 / (1.0 + exp(zSharpness * (abs(vPosition.z) - zThreshold)));
                    
                    // Calculate distance for fading
                    float distFromCenter = length(vPosition.xz);
                    
                    // Gradient color based on height
                    vec3 waveColor = mix(color2, color1, vGradientFactor);
                    
                    // Add subtle shading for 3D effect
                    float lightFactor = 0.7 + 0.3 * vWaveHeight;
                    
                    // Base transparency for the entire plane
                    float baseOpacity = 0.05;
                    
                    // Higher opacity in wave area, also affected by Z narrowing
                    float waveOpacity = 0.2 + 0.8 * vWaveHeight;
                    
                    // Combine opacities based on whether we're in wave area
                    float opacity = mix(baseOpacity, waveOpacity, vIsInWaveArea * zFactor);
                    
                    // Fade out at edges of wave area
                    opacity *= (1.0 - vEdgeFade * vIsInWaveArea);
                    
                    // Add glow from interaction
                    vec3 finalColor = waveColor * lightFactor + vec3(0.1, 0.1, 0.2) * intersectionGlow;
                    
                    gl_FragColor = vec4(finalColor, opacity);
                }
            `,
            transparent: true,
            side: THREE.DoubleSide
        });
        const wave = new THREE.Mesh(waveGeometry, waveMaterial);
        wave.rotation.x = -Math.PI / 2;
        wave.position.y = 0; // Move the wave up to be at the same level as the atom
        scene.add(wave);

        // Add a subtle reference ground plane to better see the morphing effect
        const groundGeometry = new THREE.PlaneGeometry(12, 6);
        const groundMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xcccccc, 
            transparent: true, 
            opacity: 0.1,
            wireframe: true 
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.05; // Slightly below the wave
        scene.add(ground);

        // Add coordinate axes for better orientation
        function createAxis(length, color) {
            const material = new THREE.LineBasicMaterial({ color: color });
            const points = [];
            points.push(new THREE.Vector3(0, 0, 0));
            points.push(new THREE.Vector3(length, 0, 0));
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            return new THREE.Line(geometry, material);
        }
        
        // Create X, Y, Z axes
        const xAxis = createAxis(5, 0xff0000); // Red for X-axis
        const yAxis = createAxis(5, 0x00ff00); // Green for Y-axis
        const zAxis = createAxis(5, 0x0000ff); // Blue for Z-axis
        
        // Rotate Y and Z axes to proper orientation
        yAxis.rotation.z = Math.PI / 2; // Rotate around Z to point up
        zAxis.rotation.y = Math.PI / 2; // Rotate around Y to point forward
        
        // Add axes to scene
        scene.add(xAxis);
        scene.add(yAxis);
        scene.add(zAxis);
        
        // Add axis labels with numbers
        function createAxisLabel(text, position, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            context.fillStyle = '#' + color.toString(16).padStart(6, '0');
            context.font = '24px Arial';
            context.fillText(text, 4, 24);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.position.copy(position);
            sprite.scale.set(0.5, 0.25, 1);
            return sprite;
        }
        
        // Add main axis labels
        scene.add(createAxisLabel('X', new THREE.Vector3(5.2, 0, 0), 0xff0000));
        scene.add(createAxisLabel('Y', new THREE.Vector3(0, 5.2, 0), 0x00ff00));
        scene.add(createAxisLabel('Z', new THREE.Vector3(0, 0, 5.2), 0x0000ff));
        
        // Add numbered markers on axes
        for (let i = 1; i <= 5; i++) {
            // X-axis markers
            scene.add(createAxisLabel(i.toString(), new THREE.Vector3(i, 0, 0), 0xff0000));
            
            // Y-axis markers
            scene.add(createAxisLabel(i.toString(), new THREE.Vector3(0, i, 0), 0x00ff00));
            
            // Z-axis markers
            scene.add(createAxisLabel(i.toString(), new THREE.Vector3(0, 0, i), 0x0000ff));
            
            // Negative markers (except for Y which starts at ground level)
            if (i > 0) {
                scene.add(createAxisLabel('-'+i.toString(), new THREE.Vector3(-i, 0, 0), 0xff0000));
                scene.add(createAxisLabel('-'+i.toString(), new THREE.Vector3(0, 0, -i), 0x0000ff));
            }
        }

        // GUI
        const gui = new dat.GUI();
        const params = {
            wavelength: 2.0,
            waveSpeed: 1.0,
            amplitude: 0.5,
            electronDensity: 1.0,
            topColor: '#ffffff',
            bottomColor: '#ff69b4',
            waveRadius: 5.0,
            pause: false
        };
        gui.add(params, 'wavelength', 0.5, 5).name('Wavelength').onChange((val) => {
            waveMaterial.uniforms.wavelength.value = val;
        });
        gui.add(params, 'waveSpeed', 0.1, 2).name('Wave Speed');
        gui.add(params, 'amplitude', 0.1, 1.0).name('Wave Height').onChange((val) => {
            waveMaterial.uniforms.amplitude.value = val;
        });
        gui.add(params, 'electronDensity', 0.5, 2).name('Cloud Density');
        gui.addColor(params, 'topColor').name('Wave Top Color').onChange((val) => {
            waveMaterial.uniforms.color1.value.set(val);
        });
        gui.addColor(params, 'bottomColor').name('Wave Bottom Color').onChange((val) => {
            waveMaterial.uniforms.color2.value.set(val);
        });
        gui.add(params, 'pause').name('⏸️ Pause');

        // Animation
        let time = 0;
        // In the animate function, update the cloud-wave interaction
        function animate() {
            if (!params.pause) time += 0.01;
        
            // Update shader uniforms
            waveMaterial.uniforms.time.value = time;
            waveMaterial.uniforms.speed.value = params.waveSpeed;
            waveMaterial.uniforms.wavelength.value = params.wavelength;
            waveMaterial.uniforms.amplitude.value = params.amplitude;
            cloudMaterial.uniforms.density.value = params.electronDensity;
            cloudMaterial.uniforms.time.value = time;
        
            // Electron cloud oscillation (driven by wave)
            const wavePhase = time * params.waveSpeed;
            const displacement = 0.1 * Math.sin(wavePhase * 2);
            electronCloud.position.y = displacement;
        
            // Phase shift (electron inertia)
            const delayedPhase = wavePhase - 0.3;
            electronCloud.scale.set(
                1 + 0.05 * Math.sin(delayedPhase * 2),
                1 + 0.05 * Math.cos(delayedPhase * 2),
                1
            );
        
            // Intersection glow (wave-cloud proximity)
            const distanceToCloud = Math.abs(wave.position.y - electronCloud.position.y);
            // Smoother interaction value with exponential falloff
            const interaction = Math.exp(-distanceToCloud * 2.0);
            waveMaterial.uniforms.intersectionGlow.value = interaction * 0.5;
            
            // Update cloud interaction with smoothing
            const currentInteraction = cloudMaterial.uniforms.waveInteraction.value;
            const targetInteraction = interaction * 0.6;
            // Smooth transition between values (lerp)
            cloudMaterial.uniforms.waveInteraction.value = currentInteraction * 0.9 + targetInteraction * 0.1;
            
            // Spawn re-radiated ripples at wave peaks
            if (Math.abs(wavePhase % (2 * Math.PI)) < 0.1 && !params.pause) {
                spawnRipple(electronCloud.position);
            }

            controls.update();
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }
        animate();

        // Re-radiated ripple effect
        function spawnRipple(position) {
            const geometry = new THREE.SphereGeometry(0.1, 16, 16);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x88ffff, 
                transparent: true, 
                opacity: 0.7 
            });
            const ripple = new THREE.Mesh(geometry, material);
            ripple.position.copy(position);
            scene.add(ripple);

            let scale = 0.1;
            const grow = () => {
                scale += 0.1;
                ripple.scale.set(scale, scale, scale);
                ripple.material.opacity *= 0.95;
                if (scale < 3) requestAnimationFrame(grow);
                else scene.remove(ripple);
            };
            grow();
        }

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>